# -*- coding: utf-8 -*-
"""Retail_Intelligence_Agent_System_RIA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZgVHteI92vF1nnGOxFmEEUSZVX2Qq3UV

# üìò Retail Intelligence Agent System (RIA)
### Multi-Agent Retail Analytics Using Google ADK & Gemini  
#### **Track: Enterprise Agents**

The Retail Intelligence Agent System (RIA) is a multi-agent framework designed to automate retail business intelligence using Google‚Äôs **Agent Development Kit (ADK)** and **Gemini models**.

RIA integrates:

- **Insights Agent** ‚Üí Historical KPI analytics  
- **Forecast Agent** ‚Üí 3-month demand forecasting  
- **Recommendation Agent** ‚Üí Strategy generation using insights + forecasts  
- **Coordinator Agent** ‚Üí Routes user queries to the correct agent  

RIA demonstrates essential ADK concepts:

- ‚úî Multi-Agent Systems  
- ‚úî Custom FunctionTools  
- ‚úî Sessions & Memory (InMemorySessionService)  
- ‚úî Context Engineering  
- ‚úî Observability with `run_debug()`  
- ‚úî Scalable ADK architecture  

The system analyzes historical performance, predicts future sales, and generates business recommendations.

---

# üóÇ Table of Contents

1. Introduction  
2. Setup & Requirements  
3. Dataset Loading & Cleaning  
4. Exploratory Data Analysis (EDA)  
5. Problem Definition & Use Cases  
6. ADK Architecture Overview  
7. Insights Tool + Insights Agent  
8. Forecast Tool + Forecast Agent  
9. Recommendation Agent  
10. Coordinator (Router) Agent  
11. Observability & Context Engineering  
12. Results & Visualizations  
13. Limitations  
14. Future Work  
15. Conclusion

## üîß Setup & Requirements

This cell installs the required libraries (Google ADK, Gemini, Statsmodels, Pandas, Matplotlib)  
and loads the Google API key from Kaggle Secrets.

This setup is required before creating any agent.
"""

!pip install -q google-adk google-genai statsmodels pandas matplotlib

import os
import pandas as pd
import matplotlib.pyplot as plt
from kaggle_secrets import UserSecretsClient

# Load API key from Kaggle Secrets
user_secrets = UserSecretsClient()
os.environ["GOOGLE_API_KEY"] = user_secrets.get_secret("GOOGLE_API_KEY")

print("Environment ready. ADK & Gemini successfully loaded.")

"""## üì• Dataset Loading & Cleaning

The Superstore dataset is loaded from Kaggle.  
This cell:

- Loads the CSV  
- Converts date columns  
- Creates Month, Year, Quarter  
- Removes invalid values  
- Ensures the dataset is clean for analytics & forecasting  

"""

DATA_PATH = "/kaggle/input/superstore-dataset-final/Sample - Superstore.csv"

df = pd.read_csv(DATA_PATH, encoding="latin-1")

# Convert to datetime
df["Order Date"] = pd.to_datetime(df["Order Date"])
df["Ship Date"] = pd.to_datetime(df["Ship Date"])

# Date features
df["Year"] = df["Order Date"].dt.year
df["Month"] = df["Order Date"].dt.to_period("M").astype(str)
df["Quarter"] = df["Order Date"].dt.to_period("Q").astype(str)

# Cleaning
df = df[df["Sales"] >= 0]
df = df.dropna(subset=["Sales", "Profit", "Region", "Category"])

df.head()

"""## üìä Dataset Summary

The Superstore dataset contains:

- ~10,000 customer orders  
- Sales, Profit, Quantity, Discount  
- Region, Category, Segment, State  
- 4 years of transaction history  

This dataset is suitable for multi-agent analytics, forecasting, and business recommendation tasks.

"""

df.describe(include="all").T.head(20)
df.info()

"""# üîç Exploratory Data Analysis (EDA)

We explore:

- Monthly sales trends  
- Category profitability  
- Regional performance  

These insights help validate the dataset and motivate the need for predictive agents.

"""

# Monthly sales trend
monthly_sales = (
    df.groupby(df["Order Date"].dt.to_period("M"))["Sales"].sum()
)
monthly_sales.index = monthly_sales.index.to_timestamp()

plt.figure(figsize=(12,5))
plt.plot(monthly_sales, marker="o")
plt.title("Monthly Sales Trend")
plt.xlabel("Month")
plt.ylabel("Sales")
plt.grid(True)
plt.show()

"""# üéØ Problem Definition

Retail managers face several challenges:

- Slow manual analysis  
- Fragmented forecasting  
- No unified recommendation engine  

### **RIA solves these by enabling:**

1. Automated analytics using the Insights Agent  
2. AI-driven demand forecasting  
3. Strategy recommendations grounded in data  
4. Dynamic multi-agent collaboration  

___

# üß± ADK Architecture Overview

RIA uses four agents orchestrated via ADK:



<pre>
+----------------------------------------------+
|               Coordinator Agent              |
|     (routes user queries to sub-agents)      |
+---------------------+------------------------+
                      |
        +-------------+-------------+
        |                           |
+-------------------+     +--------------------+
|   InsightsAgent   |     |   ForecastAgent    |
|     (Analysis)    |     |    (Prediction)    |
+---------+---------+     +---------+----------+
          |                           |
          +-------------+-------------+
                        |
                        v
            +------------------------------+
            |     RecommendationAgent      |
            |       (Strategy Engine)      |
            +------------------------------+
</pre>


The next cells implement each agent step-by-step.

___

## üì¶ Import ADK Components

This cell imports all ADK classes required to build:

- Agents  
- Runners  
- Session managers  
- FunctionTools
"""

from typing import Any, Dict
from google.adk.agents import LlmAgent
from google.adk.runners import Runner, InMemoryRunner
from google.adk.sessions import InMemorySessionService
from google.adk.models.google_llm import Gemini
from google.adk.tools.function_tool import FunctionTool

print("ADK components imported.")

"""## üõ† Insights Tool

This tool aggregates sales, profit, quantity, and discount by:

- Region  
- Category  
- Segment  
- Month  
- Quarter  
- Year  

The InsightsAgent will call this tool for ANY analytical question.

"""

def analyze_sales(group_by: str = "Category") -> Dict[str, Any]:
    """
    Compute grouped KPIs for the Superstore dataset.
    """
    grouped = (
        df.groupby(group_by)
          .agg(
              total_sales=("Sales", "sum"),
              total_profit=("Profit", "sum"),
              avg_profit=("Profit", "mean"),
              avg_discount=("Discount", "mean"),
              total_quantity=("Quantity", "sum")
          )
          .reset_index()
    )

    return {
        "grouped_by": group_by,
        "results": grouped.to_dict(orient="records")
    }

insights_tool = FunctionTool(analyze_sales)

"""## üß† Insights Agent

The InsightsAgent:

- Understands analytical queries  
- ALWAYS calls `insights_tool`  
- Returns clean summaries for business questions  

This cell defines the agent and creates a Runner for execution.

"""

insights_agent = LlmAgent(
    name="InsightsAgent",
    description="Agent for grouped retail analytics.",
    model=Gemini(model="gemini-2.5-flash-lite"),
    tools=[insights_tool],
    instruction=(
        "You are a retail analytics agent. "
        "For any question involving KPIs, groups, trends, or comparisons, "
        "ALWAYS call insights_tool with the correct group_by field."
    )
)

insights_runner = InMemoryRunner(agent=insights_agent)

"""### ‚úÖ Quick Test: InsightsAgent

Test the InsightsAgent on a simple analytics question to confirm that:

- It calls `insights_tool` correctly  
- It groups by the right field (Region)  
- It returns a clear business summary  

"""

test_insights_query = (
    "Show me total sales, total profit, quantity and average discount grouped by Region. "
    "Use the appropriate group_by and give a short business summary."
)

response_insights = await insights_runner.run_debug(test_insights_query)

"""## üìà Forecast Tool

The forecasting tool:

- Aggregates monthly sales  
- Fits Holt‚ÄìWinters exponential smoothing  
- Predicts next **3 months** of regional sales  

Used by the ForecastAgent.

"""

def forecast_sales(region: str = "West"):
    from statsmodels.tsa.holtwinters import ExponentialSmoothing

    df_reg = df[df["Region"] == region]
    if df_reg.empty:
        return {"error": f"Region '{region}' not found."}

    monthly = (
        df_reg.groupby(df_reg["Order Date"].dt.to_period("M"))["Sales"]
              .sum()
              .astype(float)
    )
    monthly.index = monthly.index.to_timestamp()

    model = ExponentialSmoothing(monthly, trend="add", seasonal="add", seasonal_periods=12)
    fit = model.fit()
    fc = fit.forecast(3)

    return {
        "region": region,
        "forecast_next_3_months": {k.strftime("%Y-%m-%d"): float(v) for k, v in fc.items()}
    }

forecast_tool = FunctionTool(forecast_sales)
forecast_tool.name = "forecast_sales"

"""## ü§ñ Forecast Agent

The ForecastAgent:

- Interprets forecasting queries  
- ALWAYS calls `forecast_sales`  
- Produces a forecast + short summary  

A runner is created for testing the agent.

"""

forecast_agent = LlmAgent(
    name="ForecastAgent",
    description="Predicts 3-month future sales.",
    model=Gemini(model="gemini-2.5-flash-lite"),
    tools=[forecast_tool],
    instruction=(
        "For any forecasting question, ALWAYS call forecast_sales. "
        "Use the region mentioned in the user query."
    )
)

forecast_runner = Runner(
    agent=forecast_agent,
    app_name="RIA_App",
    session_service=InMemorySessionService()
)

"""### ‚úÖ Quick Test: ForecastAgent

Test the ForecastAgent with a forecasting question to verify:

- It calls `forecast_sales`  
- Uses the correct region  
- Produces a 3-month forecast with an explanation  

"""

test_forecast_query = (
    "Forecast total sales for the next 3 months in the West region. "
    "Use the forecasting tool and explain the trend briefly."
)

response_forecast = await forecast_runner.run_debug(test_forecast_query)

"""## üß© Recommendation Agent

This agent combines:

1. Insights (past performance)  
2. Forecasts (future demand)  

‚Ä¶and produces **3‚Äì5 actionable business recommendations**.

This is the core decision-support agent.

"""

recommendation_agent = LlmAgent(
    name="RecommendationAgent",
    description="Generates strategic retail recommendations.",
    model=Gemini(model="gemini-2.5-flash-lite"),
    tools=[insights_tool, forecast_tool],
    instruction=(
        "You are a senior retail strategist.\n"
        "Step 1: ALWAYS call insights_tool for KPIs.\n"
        "Step 2: ALWAYS call forecast_sales for demand.\n"
        "Step 3: Combine both into actionable recommendations.\n"
        "Always cite numeric values."
    )
)

recommendation_runner = Runner(
    agent=recommendation_agent,
    app_name="RIA_App",
    session_service=InMemorySessionService()
)

"""### ‚úÖ Quick Test: RecommendationAgent

This test checks that the RecommendationAgent:

1. Calls `insights_tool` for past KPIs  
2. Calls `forecast_sales` for future demand  
3. Combines both into concrete business recommendations  

"""

test_reco_query = (
    "For the West region and Furniture category, analyse current sales, profit, "
    "quantity and discount, forecast total sales for the next 3 months, and "
    "suggest 3 concrete actions to improve profit. "
)

response_reco = await recommendation_runner.run_debug(test_reco_query)

"""## üß≠ Coordinator (Router) Agent

This layer automatically selects the correct agent based on the user's query.

- Forecast questions ‚Üí ForecastAgent  
- Strategy questions ‚Üí RecommendationAgent  
- All other analytics ‚Üí InsightsAgent  

"""

def route_query(query: str) -> str:
    q = query.lower()

    if any(k in q for k in ["forecast", "predict", "future", "projection"]):
        return "forecast"

    if any(k in q for k in ["recommend", "strategy", "improve", "action"]):
        return "recommend"

    return "insights"

"""## ‚ñ∂ Unified RIA Execution Function

This function executes the correct agent through the router  
and prints model traces using `run_debug()`.

"""

async def run_ria(query: str):
    route = route_query(query)

    if route == "forecast":
        return await forecast_runner.run_debug(query)
    elif route == "recommend":
        return await recommendation_runner.run_debug(query)
    else:
        return await insights_runner.run_debug(query)

"""### ‚ñ∂ End-to-End Tests: Retail Intelligence Agent System (RIA)

Now we query the unified RIA entrypoint `run_ria(...)`.  
The router decides which agent to use automatically based on the question.

"""

# 1) Pure analytics question ‚Üí should route to InsightsAgent
q1 = "Compare total sales and profit by Region and highlight the best and worst performing regions."
await run_ria(q1)

# 2) Forecasting question ‚Üí should route to ForecastAgent
q2 = "Forecast sales for the next 3 months in the Central region and explain if it is growing or declining."
await run_ria(q2)

# 3) Strategy question ‚Üí should route to RecommendationAgent
q3 = (
    "Given the current performance in the West region, suggest 3 actionable strategies "
    "to improve overall profit in the next quarter."
)
await run_ria(q3)

"""### üí¨Interactive RIA Chat
To make the system easier to use, I expose a single entry point:
`chat_with_ria()`.  
A small router function inspects the user‚Äôs query and decides whether to call:

- the **Insights Agent** (analytics),
- the **Forecast Agent** (time-series forecasting), or
- the **Recommendation Agent** (strategy and actions).

This mirrors the Coordinator/Orchestrator pattern from the course.


Type 'exit' to stop.

"""

async def chat_with_ria():
    print("üí¨ Retail Intelligence Agent System (RIA)")
    print("Type 'exit' to stop.\n")
    while True:
        user_message = input("You: ")
        if user_message.lower() in ["exit", "quit"]:
            print("Goodbye!")
            break
        await run_ria(user_message)

# comment if you don't want to use:
await chat_with_ria()

"""# üõ∞ Observability & Context Engineering

`run_debug()` shows:

- Tool call arguments  
- Intermediate reasoning  
- Generated traces  
- Final model response  

This fulfills **Day 4 ‚Äì Agent Quality** requirements.

# üìä Results & Visualizations
"""

region = "West"

forecast_data = forecast_sales(region)["forecast_next_3_months"]
forecast_series = pd.Series(forecast_data)
forecast_series.index = pd.to_datetime(forecast_series.index)

plt.figure(figsize=(12,5))
plt.plot(monthly_sales[-12:], label="Last 12 Months")
plt.plot(forecast_series, marker="o", label="Next 3-Month Forecast")
plt.title(f"Sales Forecast for {region} Region")
plt.ylabel("Sales")
plt.legend()
plt.grid(True)
plt.show()

category_profit = df.groupby("Category")["Profit"].sum().sort_values()

plt.figure(figsize=(8,5))
plt.bar(category_profit.index, category_profit.values, color="purple")
plt.title("Total Profit by Category")
plt.ylabel("Profit")
plt.show()

"""# ‚ö† Limitations

- Holt‚ÄìWinters cannot model shocks/holidays  
- Category-level forecasting not implemented  
- Keyword-based router instead of semantic router  
- No database integration or real-time streaming

## üîÆ Future Work

To further enhance the Retail Intelligence Agent System (RIA), the following improvements are recommended:

1. **More Forecasting Models**  
   Add ARIMA, Prophet, LightGBM, or hybrid deep-learning models for improved accuracy.

2. **Customer Segmentation Module**  
   Implement RFM scoring, clustering, or churn prediction.

3. **Real-Time Pipeline Integration**  
   Connect the system with cloud databases (BigQuery, Firestore, PostgreSQL).

4. **Interactive RIA Dashboard**  
   Build a Streamlit/Gradio dashboard with charts and agent chat interface.

5. **Automated Anomaly Detection**  
   Identify sudden drops in sales, discounts, margin erosion, or unusual inventory patterns.

6. **Promotion Optimization Engine**  
   Suggest promotional strategies using uplift modelling or price elasticity analysis.

7. **More Advanced Multi-Agent Collaboration**  
   Introduce new agents such as Pricing Agent, Inventory Agent, or Customer Experience Agent.

## üßæ Conclusion

The Retail Intelligence Agent System (RIA) integrates LLM-powered reasoning,
analytical tooling, and time-series forecasting to support retail
decision-making.

Using Google ADK, the system coordinates:

- **Insights Tool** ‚Äì performs grouped sales, profit, discount, and quantity analysis.  
- **Forecast Tool** ‚Äì predicts future sales using Holt‚ÄìWinters Exponential Smoothing.  
- **Recommendation Agent** ‚Äì combines insights + forecasts to generate actionable strategy.  
- **Session & State Support** ‚Äì `InMemorySessionService` enables multi-turn conversations,
  where follow-up questions can refer back to previous context.

The agents:

- Interpret natural-language questions.  
- Automatically invoke the relevant `FunctionTool`s.  
- Process analytics and forecasting requests.  
- Produce clear, human-friendly business recommendations.

This demonstrates how LLM-based agents can bridge the gap between raw retail data and
strategic decision-making, following the architectures and patterns from the
5-Day AI Agents Intensive course.
"""

